[
  {
    "objectID": "Homework6.html",
    "href": "Homework6.html",
    "title": "homework6",
    "section": "",
    "text": "What is the purpose of lapply() function? What is the equivalent purrr funtion?\n\n\nThe purpose of lapply() is to apply a function to a list. The equivalent purrr function is map().\n\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code or cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below.\n\n\nlapply(my_list, function(x) cor(numeric_matrix, method = “kendall”))\n\n\nWhar are two advantages of using purrr functions instead of BaseR apply family?\n\n\nTwo advantages of using the purrr functions instead of BaseR apply family is that there is more consistency and some helper functions. Also almost every purrr function is type stable(you can predict the output type exclusively from the function name).\n\n\nWhat is a side-effect function?\n\n\na side effect function is a function that doesn’t change the data but produces something some examples are print(), read_csv(), and plot().\n\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\n\nYou can name a variable sd in a function and not cause any issues with the sd function because when you call a function it creates a temporary function environments."
  },
  {
    "objectID": "Homework6.html#task-1-conceptual-questions",
    "href": "Homework6.html#task-1-conceptual-questions",
    "title": "homework6",
    "section": "",
    "text": "What is the purpose of lapply() function? What is the equivalent purrr funtion?\n\n\nThe purpose of lapply() is to apply a function to a list. The equivalent purrr function is map().\n\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code or cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below.\n\n\nlapply(my_list, function(x) cor(numeric_matrix, method = “kendall”))\n\n\nWhar are two advantages of using purrr functions instead of BaseR apply family?\n\n\nTwo advantages of using the purrr functions instead of BaseR apply family is that there is more consistency and some helper functions. Also almost every purrr function is type stable(you can predict the output type exclusively from the function name).\n\n\nWhat is a side-effect function?\n\n\na side effect function is a function that doesn’t change the data but produces something some examples are print(), read_csv(), and plot().\n\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\n\nYou can name a variable sd in a function and not cause any issues with the sd function because when you call a function it creates a temporary function environments."
  },
  {
    "objectID": "Homework6.html#task-2-writing-r-functions",
    "href": "Homework6.html#task-2-writing-r-functions",
    "title": "homework6",
    "section": "Task 2: Writing R Functions",
    "text": "Task 2: Writing R Functions\n\nWhen we start doing machine learning later in the course, a common metric used to evaluate predictions is called Root Mean Square Error (RMSE). For a given set of responses _*y1,…,yn the RMSE is defined as\n\n\nWrite a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs RMSE - If a value is missing for the vector of responses (i.e. an NA is present), allow for additional arguments to the mean() function (elipses) that removes the NA values in the computation\nwrite code here\n\ngetRMSE &lt;- function(x, y, na.rm = TRUE, ...) {\n  residuals &lt;- x - y\n  rmse &lt;- sqrt(mean(residuals^2, ...))\n  return(rmse)\n}\n\n\nRun the following code to create some response values and predictions loading libraries\n\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.5.1\n\n\nWarning: package 'ggplot2' was built under R version 4.5.1\n\n\nWarning: package 'tibble' was built under R version 4.5.1\n\n\nWarning: package 'tidyr' was built under R version 4.5.1\n\n\nWarning: package 'readr' was built under R version 4.5.1\n\n\nWarning: package 'purrr' was built under R version 4.5.1\n\n\nWarning: package 'dplyr' was built under R version 4.5.1\n\n\nWarning: package 'stringr' was built under R version 4.5.1\n\n\nWarning: package 'forcats' was built under R version 4.5.1\n\n\nWarning: package 'lubridate' was built under R version 4.5.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(purrr)\nlibrary(jsonlite)\n\nWarning: package 'jsonlite' was built under R version 4.5.1\n\n\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\n\n\nset.seed(10)\nn &lt;- 100 \nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\ntest RMSE function using this data\n\ngetRMSE &lt;- function(resp, pred, ...) {\n  residuals &lt;- resp - pred\n  rmse &lt;- sqrt(mean(residuals^2, ...))\n  return(rmse)\n}\ngetRMSE(resp, pred)\n\n[1] 0.9581677\n\n\ntest again after manually replaces two of the response values with missing values (NA_real_)(just assign two values to NA_real_)\nTest RMSE function with and without specifying the behavior to deal with missing values\n\n#testing with specifying dealing with missing values \nresp &lt;- c(1,2, NA, 5)\npred &lt;- c(4, 8, 12, 16)\ngetRMSE(resp, pred, na.rm = FALSE)\n\n[1] NA\n\n\n\n#testing without specifying how to deal with missing values \nresp &lt;- c(1,2, NA, 5)\npred &lt;- c(4, 8, 12, 16)\ngetRMSE(resp, pred, na.rm = TRUE)\n\n[1] 7.438638\n\n\n\nAnother common metric for evaluating predictions is mean absolute deviation given by\n\nWrite a function called getMAE() that follows the specifications of the getRMSE() function\n\n\ngetMAE &lt;- function(resp, pred, ...) {\n  residuals &lt;- resp - pred\n  mae &lt;- sqrt(mean(residuals^2, ...))\n  return(mae)\n}\n  \ngetMAE(resp, pred)\n\n[1] NA\n\n\n\nRun the following code to create some response values and predictions\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest MAE function using this data\n\ngetMAE &lt;- function(resp, pred, ...) {\n  residuals &lt;- abs(resp - pred)\n  mae &lt;- mean(residuals, ...)\n  return(mae)\n}\n  \ngetMAE(resp, pred)\n\n[1] 0.8155776\n\n\nRepeat after replacing two of the response values with missing values (NA_real_) - Test MAE function with and without specifying the behavior to deal with the missing values\n\n#Testing with specifying how to deal with missing values \nresp &lt;- c(1,2, NA, 5)\npred &lt;- c(4, 8, 12, 16)\ngetMAE(resp, pred, na.rm = TRUE)\n\n[1] 6.666667\n\n\n\n#Testing without specifying how to deal with missing values \nresp &lt;- c(1,2, NA, 5)\npred &lt;- c(4, 8, 12, 16)\ngetRMSE(resp, pred, na.rm = FALSE)\n\n[1] NA\n\n\n\nLets create a wrapper function that can be used to get either or both metrics returned with a single function call. DO not rewrite your above two functions, call them inside the wrapper function (we would call getRMSE() and getMAE() functions helper functions). When returning your values, give them appropriate names additionally the wrapper function should\n\n\ncheck that the two numeric(atomic) vectors have been passes (consider is.vector(), is.atomic() and is.numeric()). If not, the function should stop and print an informative message.\nReturn both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find\n\n\ngetMetrics &lt;- function(resp, pred, metric = c(\"RMSE\", \"MAE\"), ...) {\n  # Check that data is numeric/atomic\n  if (!is.numeric(resp) || !is.numeric(pred))\n    stop(\"Both variables must be numeric.\")\n  \n  # Compute requested metrics\n  result &lt;- c()\n  if (\"RMSE\" %in% metric) result[\"RMSE\"] &lt;- getRMSE(resp, pred, ...)\n  if (\"MAE\"  %in% metric) result[\"MAE\"]  &lt;- getMAE(resp, pred, ...)\n  \n  return(result)\n}\n\n\nRun the following code to create some response values and predictions\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest your new function using this data. Call it once asking for each metric individually and once specifying both metrics\n\ngetMetrics(resp, pred, na.rm = FALSE)\n\n     RMSE       MAE \n0.9581677 0.8155776 \n\n\nRepeat with replacing two of the response values with missing values (NA_real_)\n\nresp[1:2] &lt;- NA_real_\n\nFinally, test your function by passing it incorrect data (i.e. a data frame or something else instead of vectors)\n\ngetMetrics(resp, pred)\n\nRMSE  MAE \n  NA   NA"
  },
  {
    "objectID": "Homework6.html#task-3-practice-with-purrr",
    "href": "Homework6.html#task-3-practice-with-purrr",
    "title": "homework6",
    "section": "Task 3: Practice with purrr",
    "text": "Task 3: Practice with purrr\nimport purrr\n\nlibrary(purrr)\n\nLet’s create an interesting list object we can play around with\n\nlm_fit1 &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)\n\n\npull of the coefficients list element using $, coef(), and the pluck() function from purrr\n\n\nlm_fit1$coefficients\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\ncoef(lm_fit1)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\nlm_fit1 |&gt;\n  pluck(coefficients)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n\nlets fit a number of different models with the code below\n\nlm_fit2 &lt;- lm(Sepal.Length ~ Sepal.Width, data = iris)\nlm_fit3 &lt;- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)\nlm_fit4 &lt;- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species,\n data = iris)\nfits &lt;- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)\n\nNow let’s use the purrr::map() function to pull out the coefficients of each model fit from the fits object(using pluck!)\n\nmap(fits, confint)\n\n[[1]]\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n[[2]]\n                2.5 %     97.5 %\n(Intercept)  5.579865 7.47258038\nSepal.Width -0.529820 0.08309785\n\n[[3]]\n                        2.5 %    97.5 %\n(Intercept)        1.74261803 3.2995285\nPetal.Width       -0.02042746 0.7635811\nSepal.Width        0.46205710 0.9343950\nSpeciesversicolor  0.44520784 1.5310516\nSpeciesvirginica   0.46412393 2.0110518\n\n[[4]]\n                       2.5 %      97.5 %\n(Intercept)        1.6182321  2.72430044\nPetal.Width       -0.6140049 -0.01630542\nPetal.Length       0.6937939  0.96469395\nSepal.Width        0.3257653  0.66601260\nSpeciesversicolor -1.1982739 -0.24885002\nSpeciesvirginica  -1.6831329 -0.36386273\n\n\n\nThere is a function called confint() that creates confidence intervals for the coefficients in an lm()fit. We apply that function directly to the fitted object like this:\n\n\nconfint(lm_fit1)\n\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n\nUse map() to apply cofint() function to each model in the fits object\n\nmap(fits, confint)\n\n[[1]]\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n[[2]]\n                2.5 %     97.5 %\n(Intercept)  5.579865 7.47258038\nSepal.Width -0.529820 0.08309785\n\n[[3]]\n                        2.5 %    97.5 %\n(Intercept)        1.74261803 3.2995285\nPetal.Width       -0.02042746 0.7635811\nSepal.Width        0.46205710 0.9343950\nSpeciesversicolor  0.44520784 1.5310516\nSpeciesvirginica   0.46412393 2.0110518\n\n[[4]]\n                       2.5 %      97.5 %\n(Intercept)        1.6182321  2.72430044\nPetal.Width       -0.6140049 -0.01630542\nPetal.Length       0.6937939  0.96469395\nSepal.Width        0.3257653  0.66601260\nSpeciesversicolor -1.1982739 -0.24885002\nSpeciesvirginica  -1.6831329 -0.36386273\n\n\n\nNext, let’s create histograms of the residuals in each model fit! Run the code here to set up a 2x2 plotting window\n\n\npar(mfrow = c(2, 2))\n\nNow, pull out the residual vectors (the resid elements of your fits) using map(). Then use the walk() function with hist to create plots\n\nresiduals &lt;- map(fits, resid) |&gt; \n  walk(hist)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThat was cool! However, the names stink… Let’s try to fix that! On the list that is created from the map() function used on the resid element, use the purrr::set_names() function to give the names “fit1”, “fit2”, “fit3”, and “fit4” to the list elements.\n\n\nset_names(c('fit1', 'fit2', 'fit3', 'fit4'))\n\n  fit1   fit2   fit3   fit4 \n\"fit1\" \"fit2\" \"fit3\" \"fit4\" \n\n\nWith the names set, we now want to use the walk() function. However, it doesn’t add the names appropriately! (Try it yourself.)\n\npar(mfrow = c(2,2))\nwalk(residuals, ~ hist(.x, main = \"Residuals\"))\n\n\n\n\n\n\n\n\nInstead, we want to use iwalk(). This is a function under the imap() help\n\nresiduals |&gt; \n  set_names(c('fit1', 'fit2', 'fit3', 'fit4')) |&gt;\n  iwalk(\\(x, names) hist(x, main = paste('Residuals for', names)))"
  }
]